using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Dynamic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.IO.Compression;
using System.Text.RegularExpressions;
using System.Windows.Input;
using System.Windows.Media;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;

namespace XMindParser
{
    public class XMindParser
    {
        public bool Overwrite = false;

        public XMindParser() { }

        public static string GetPathAt(string[] path, string lastFolder)
        {
            StringBuilder sb = new StringBuilder();
            foreach (string folder in path)
            {
                sb.Append($"{folder}\\");
                if (folder == lastFolder) break;
            }
            return sb.ToString();
        }

        public List<string> GetLinesBetweenIndicators(string filePath, string startIndicator, string stopIndicator)
        {
            List<string> allLines = File.ReadAllLines(filePath).ToList();
            List<string> linesToReturn = new List<string>();
            startIndicator = startIndicator.Trim();
            stopIndicator = stopIndicator.Trim();

            bool inRegion = false;
            foreach (var line in allLines)
            {
                var candidate = line.Trim();
                if (inRegion)
                {
                    if (!candidate.StartsWith(stopIndicator))
                    {
                        linesToReturn.Add(candidate); 
                    }
                    else
                    {
                        inRegion = false;
                    }
                }
                else if (candidate.StartsWith(startIndicator))
                {
                    inRegion = true;
                }
            }

            return linesToReturn;
        }

        public void EditApplicationFile(string appCodeLocation, List<string> lines, string indicator)
        {
            // Get Application.cs template
            string[] appTemplate = File.ReadAllLines(appCodeLocation);
            StringBuilder appStringBuilder = new StringBuilder();
            StringBuilder appSectionBuilder = new StringBuilder();
            bool inAutoGeneratedRegion = false;
            bool addedAutoGeneratedCode = false;
            string indent = "";

            foreach (string line in appTemplate)
            {
                if (line.Contains($"// END {indicator}"))
                {
                    inAutoGeneratedRegion = false;
                }
                if (!inAutoGeneratedRegion) appStringBuilder.AppendLine(indent + line);

                if (line.Contains($"// BEGIN {indicator}"))
                {
                    inAutoGeneratedRegion = true;
                    indent = new string(' ', line.IndexOf('/'));
                }

                if (inAutoGeneratedRegion && !addedAutoGeneratedCode) // Add generated code
                {
                    appSectionBuilder.Append(appStringBuilder);
                    appStringBuilder.Clear();

                    foreach (string s in lines)
                    {
                        appSectionBuilder.AppendLine(indent + s);
                    }
                    addedAutoGeneratedCode = true;
                    indent = "";
                }
            }
            appSectionBuilder.Append(appStringBuilder.ToString());
            string generatedAppFile = appSectionBuilder.ToString();
            File.WriteAllText(appCodeLocation, generatedAppFile);
        }

        public string GenerateCodeFromDiagram(string xmindPath, string appcsPath)
        {
            string fileName = Regex.Match(xmindPath, @"(?<=\\)[^\\]*\.xmind$").Value;
            string json = GetJsonFromXmindFile(xmindPath);

            ALAGraph graph = new ALAGraph();
            graph.GetSheets(json);
            string sheetName = "";
            graph.GetNodesById(sheetName: sheetName);
            graph.GetRelationships(sheetName: sheetName);
            graph.GetWiring();

            string generatedCode = "";
            StringBuilder initStringBuilder = new StringBuilder();
            StringBuilder wiringStringBuilder = new StringBuilder();
            List<string> initStrings = graph.InstantiationLines.Values.OrderBy(s => s).ToList();
            List<string> wiringStrings = graph.WiringLines;

            foreach (var line in initStrings)
            {
                initStringBuilder.AppendLine(line);
            }

            foreach (var line in wiringStrings)
            {
                wiringStringBuilder.AppendLine(line);
            }

            generatedCode = initStringBuilder.ToString() + "\n" + wiringStringBuilder.ToString();

            if (Overwrite)
            {
                EditApplicationFile(appcsPath, initStrings, "AUTO-GENERATED INSTANTIATIONS FOR " + fileName);
                EditApplicationFile(appcsPath, wiringStrings, "AUTO-GENERATED WIRING FOR " + fileName);
            }

            return generatedCode;
        }

        public string GetJsonFromXmindFile(string xmindPath)
        {
            if (!Directory.Exists(@".\buffers")) Directory.CreateDirectory(@".\buffers");
            string jsonPath = @".\buffers\ZenParserBuffer.json";
            if (!File.Exists(jsonPath))
            {
                var writer = File.CreateText(jsonPath);
                writer.Close();
            }

            var zip = ZipFile.OpenRead(xmindPath);
            if (File.Exists(jsonPath))
            {
                File.Delete(jsonPath);
            }
            zip.GetEntry("content.json").ExtractToFile(jsonPath);
            zip.Dispose(); // Allow the diagram to be modified while the parser is open

            return File.ReadAllText(jsonPath);
        }

        public string Parse(string xmindPath, string appcsPath)
        {
            if (!Directory.Exists(@".\buffers")) Directory.CreateDirectory(@".\buffers");
            string jsonPath = @".\buffers\ZenParserBuffer.json";
            if (!File.Exists(jsonPath))
            {
                var writer = File.CreateText(jsonPath);
                writer.Close();
            }

            string json = "";
            var zip = ZipFile.OpenRead(xmindPath);
            if (File.Exists(jsonPath))
            {
                File.Delete(jsonPath);
            }
            zip.GetEntry("content.json").ExtractToFile(jsonPath);
            json = File.ReadAllText(jsonPath);

            ALAGraph graph = new ALAGraph();
            graph.GetSheets(json);
            string sheetName = "";
            graph.GetNodesById(sheetName: sheetName);
            graph.GetRelationships(sheetName: sheetName);
            graph.GetWiring();

            string generatedCode = "";
            StringBuilder initStringBuilder = new StringBuilder();
            StringBuilder wiringStringBuilder = new StringBuilder();
            List<string> initStrings = graph.InstantiationLines.Values.OrderBy(s => s).ToList();
            List<string> wiringStrings = graph.WiringLines;

            foreach (var line in initStrings)
            {
                initStringBuilder.AppendLine(line);
            }

            foreach (var line in wiringStrings)
            {
                wiringStringBuilder.AppendLine(line);
            }

            generatedCode = initStringBuilder.ToString() + "\n" + wiringStringBuilder.ToString();

            if (Overwrite)
            {
                EditApplicationFile(appcsPath, initStrings, "AUTO-GENERATED INSTANTIATIONS");
                EditApplicationFile(appcsPath, wiringStrings, "AUTO-GENERATED WIRING");
            }

            zip.Dispose(); // Allow the diagram to be modified while the parser is open
            return generatedCode;
        }

        public void CreateXmindFile(string templatePath, string newFilePath, string contentJson)
        {
            var zip = ZipFile.OpenRead(templatePath);
            string tempPath = $".\\temp_{Guid.NewGuid()}\\";
            zip.ExtractToDirectory(tempPath);
            zip.Dispose();
            File.WriteAllText(tempPath + "content.json", contentJson);
            ZipFile.CreateFromDirectory(tempPath, newFilePath);
            Directory.Delete(tempPath, true);
        }

        /// <summary>
        /// Parses a string and returns its parameters given a format.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="format"></param>
        public Dictionary<string, string> InverseStringFormat(string input, string format)
        {
            List<string> names = (from Match match in Regex.Matches(format, @"(?<={).*?(?=})") select match.Value).ToList();
            List<string> values = new List<string>();
            foreach (var name in names)
            {
                string currentParam = $"{{{name}}}";
                string before = format.Substring(0, format.IndexOf(currentParam));
                string after = format.Substring(format.IndexOf(currentParam) + currentParam.Length);
                string escapeRegex = @"(?=[\\\*\+\?\|\{\}\[\]\(\)\^\$\.\#])";
                string regexFormat = $"(?<=({Regex.Replace(before, escapeRegex, "\\")})).*?(?=({Regex.Replace(after, escapeRegex, "\\")}))";
                string patternWithOtherParamsReplaced = Regex.Replace(regexFormat, @"\\{.*?\\}", ".*?");
                values.Add(Regex.Match(input, patternWithOtherParamsReplaced).Value);
            }

            Dictionary<string, string> nameValueDictionary = new Dictionary<string, string>();
            for (int i = 0; i < names.Count; i++)
            {
                nameValueDictionary[names[i]] = values[i];
            }

            return nameValueDictionary;
        }

        /// <summary>
        /// A refactor of the InverseStringFormat method that uses a state machine.
        /// Parses a string and returns its parameters given a format.
        /// This process will terminate once it reaches the end of formatString, so inputString can be much larger than formatString.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="format"></param>
        public Dictionary<string, string> InverseStringFormatRefactor(string inputString, string formatString)
        {
            var input = inputString.ToCharArray();
            var format = formatString.ToCharArray();
            char beginNameRegionChar = '~';
            char endNameRegionChar = '~';

            var inputIndex = 0;
            var formatIndex = 0;
            var separatorIndex = 0;
            char c;
            char nextSegmentStartChar = default(char);
            List<char> separator = new List<char>();
            StringBuilder currentName = new StringBuilder();
            StringBuilder currentValue = new StringBuilder();

            List<string> names = new List<string>();
            List<string> values = new List<string>();
            Dictionary<string, string> nameValueDictionary = new Dictionary<string, string>();

            InitState:
                if (inputIndex >= input.Length || formatIndex >= format.Length) goto EndState;

                c = format[formatIndex++];
                if (c == beginNameRegionChar)
                {
                    goto GetName;
                }
                else
                {
                    separator.Add(c);
                    goto InitState;
                }

            GetName:
                if (inputIndex >= input.Length || formatIndex >= format.Length) goto EndState;

                c = format[formatIndex++];
                if (c == endNameRegionChar)
                {
                    names.Add(currentName.ToString());
                    currentName.Clear();
                    if (formatIndex < format.Length) nextSegmentStartChar = format[formatIndex];
                    goto GetValue;
                }
                else
                {
                    currentName.Append(c);
                    goto GetName;
                }

            GetValue:
                if (inputIndex >= input.Length || formatIndex >= format.Length) goto EndState;

                c = input[inputIndex++];
                if (separatorIndex < separator.Count && c == separator[separatorIndex++])
                {
                    goto GetValue;
                }
                else if (c == nextSegmentStartChar)
                {
                    values.Add(currentValue.ToString());
                    currentValue.Clear();
                    separatorIndex = 0;
                    separator.Clear();
                    inputIndex--;
                    goto InitState;
                }
                else
                {
                    currentValue.Append(c);
                    goto GetValue;
                }

            EndState:
                for (int i = 0; i < names.Count; i++)
                {
                    nameValueDictionary[names[i]] = values[i];
                }

            return nameValueDictionary;
        }

        public void SetInstanceColours(string jsonString)
        {
            XMindGraph graph = new XMindGraph();
            JObject sheet = graph.CreateGraphFromJson(jsonString);
        }
    }
}
